// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/thanhpp/scm/ent/item"
	"github.com/thanhpp/scm/ent/predicate"
	"github.com/thanhpp/scm/ent/serial"
	"github.com/thanhpp/scm/ent/storage"
	"github.com/thanhpp/scm/ent/supplier"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeItem     = "Item"
	TypeSerial   = "Serial"
	TypeStorage  = "Storage"
	TypeSupplier = "Supplier"
)

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	sku                *string
	desc               *string
	sell_price         *float64
	addsell_price      *float64
	clearedFields      map[string]struct{}
	item_serial        map[string]struct{}
	removeditem_serial map[string]struct{}
	cleareditem_serial bool
	done               bool
	oldValue           func(context.Context) (*Item, error)
	predicates         []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id uuid.UUID) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSku sets the "sku" field.
func (m *ItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ItemMutation) ResetSku() {
	m.sku = nil
}

// SetDesc sets the "desc" field.
func (m *ItemMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ItemMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ItemMutation) ResetDesc() {
	m.desc = nil
}

// SetSellPrice sets the "sell_price" field.
func (m *ItemMutation) SetSellPrice(f float64) {
	m.sell_price = &f
	m.addsell_price = nil
}

// SellPrice returns the value of the "sell_price" field in the mutation.
func (m *ItemMutation) SellPrice() (r float64, exists bool) {
	v := m.sell_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSellPrice returns the old "sell_price" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSellPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellPrice: %w", err)
	}
	return oldValue.SellPrice, nil
}

// AddSellPrice adds f to the "sell_price" field.
func (m *ItemMutation) AddSellPrice(f float64) {
	if m.addsell_price != nil {
		*m.addsell_price += f
	} else {
		m.addsell_price = &f
	}
}

// AddedSellPrice returns the value that was added to the "sell_price" field in this mutation.
func (m *ItemMutation) AddedSellPrice() (r float64, exists bool) {
	v := m.addsell_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellPrice resets all changes to the "sell_price" field.
func (m *ItemMutation) ResetSellPrice() {
	m.sell_price = nil
	m.addsell_price = nil
}

// AddItemSerialIDs adds the "item_serial" edge to the Serial entity by ids.
func (m *ItemMutation) AddItemSerialIDs(ids ...string) {
	if m.item_serial == nil {
		m.item_serial = make(map[string]struct{})
	}
	for i := range ids {
		m.item_serial[ids[i]] = struct{}{}
	}
}

// ClearItemSerial clears the "item_serial" edge to the Serial entity.
func (m *ItemMutation) ClearItemSerial() {
	m.cleareditem_serial = true
}

// ItemSerialCleared reports if the "item_serial" edge to the Serial entity was cleared.
func (m *ItemMutation) ItemSerialCleared() bool {
	return m.cleareditem_serial
}

// RemoveItemSerialIDs removes the "item_serial" edge to the Serial entity by IDs.
func (m *ItemMutation) RemoveItemSerialIDs(ids ...string) {
	if m.removeditem_serial == nil {
		m.removeditem_serial = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.item_serial, ids[i])
		m.removeditem_serial[ids[i]] = struct{}{}
	}
}

// RemovedItemSerial returns the removed IDs of the "item_serial" edge to the Serial entity.
func (m *ItemMutation) RemovedItemSerialIDs() (ids []string) {
	for id := range m.removeditem_serial {
		ids = append(ids, id)
	}
	return
}

// ItemSerialIDs returns the "item_serial" edge IDs in the mutation.
func (m *ItemMutation) ItemSerialIDs() (ids []string) {
	for id := range m.item_serial {
		ids = append(ids, id)
	}
	return
}

// ResetItemSerial resets all changes to the "item_serial" edge.
func (m *ItemMutation) ResetItemSerial() {
	m.item_serial = nil
	m.cleareditem_serial = false
	m.removeditem_serial = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, item.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, item.FieldUpdateTime)
	}
	if m.sku != nil {
		fields = append(fields, item.FieldSku)
	}
	if m.desc != nil {
		fields = append(fields, item.FieldDesc)
	}
	if m.sell_price != nil {
		fields = append(fields, item.FieldSellPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCreateTime:
		return m.CreateTime()
	case item.FieldUpdateTime:
		return m.UpdateTime()
	case item.FieldSku:
		return m.Sku()
	case item.FieldDesc:
		return m.Desc()
	case item.FieldSellPrice:
		return m.SellPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case item.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case item.FieldSku:
		return m.OldSku(ctx)
	case item.FieldDesc:
		return m.OldDesc(ctx)
	case item.FieldSellPrice:
		return m.OldSellPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case item.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case item.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case item.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case item.FieldSellPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addsell_price != nil {
		fields = append(fields, item.FieldSellPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldSellPrice:
		return m.AddedSellPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldSellPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case item.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case item.FieldSku:
		m.ResetSku()
		return nil
	case item.FieldDesc:
		m.ResetDesc()
		return nil
	case item.FieldSellPrice:
		m.ResetSellPrice()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item_serial != nil {
		edges = append(edges, item.EdgeItemSerial)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeItemSerial:
		ids := make([]ent.Value, 0, len(m.item_serial))
		for id := range m.item_serial {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeditem_serial != nil {
		edges = append(edges, item.EdgeItemSerial)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeItemSerial:
		ids := make([]ent.Value, 0, len(m.removeditem_serial))
		for id := range m.removeditem_serial {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem_serial {
		edges = append(edges, item.EdgeItemSerial)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeItemSerial:
		return m.cleareditem_serial
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeItemSerial:
		m.ResetItemSerial()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// SerialMutation represents an operation that mutates the Serial nodes in the graph.
type SerialMutation struct {
	config
	op             Op
	typ            string
	id             *string
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	item           *uuid.UUID
	cleareditem    bool
	storage        *uuid.UUID
	clearedstorage bool
	done           bool
	oldValue       func(context.Context) (*Serial, error)
	predicates     []predicate.Serial
}

var _ ent.Mutation = (*SerialMutation)(nil)

// serialOption allows management of the mutation configuration using functional options.
type serialOption func(*SerialMutation)

// newSerialMutation creates new mutation for the Serial entity.
func newSerialMutation(c config, op Op, opts ...serialOption) *SerialMutation {
	m := &SerialMutation{
		config:        c,
		op:            op,
		typ:           TypeSerial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSerialID sets the ID field of the mutation.
func withSerialID(id string) serialOption {
	return func(m *SerialMutation) {
		var (
			err   error
			once  sync.Once
			value *Serial
		)
		m.oldValue = func(ctx context.Context) (*Serial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Serial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSerial sets the old Serial of the mutation.
func withSerial(node *Serial) serialOption {
	return func(m *SerialMutation) {
		m.oldValue = func(context.Context) (*Serial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SerialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SerialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Serial entities.
func (m *SerialMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SerialMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SerialMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Serial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SerialMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SerialMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Serial entity.
// If the Serial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerialMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SerialMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SerialMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SerialMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Serial entity.
// If the Serial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerialMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SerialMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStorageID sets the "storage_id" field.
func (m *SerialMutation) SetStorageID(u uuid.UUID) {
	m.storage = &u
}

// StorageID returns the value of the "storage_id" field in the mutation.
func (m *SerialMutation) StorageID() (r uuid.UUID, exists bool) {
	v := m.storage
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageID returns the old "storage_id" field's value of the Serial entity.
// If the Serial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerialMutation) OldStorageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageID: %w", err)
	}
	return oldValue.StorageID, nil
}

// ResetStorageID resets all changes to the "storage_id" field.
func (m *SerialMutation) ResetStorageID() {
	m.storage = nil
}

// SetItemID sets the "item_id" field.
func (m *SerialMutation) SetItemID(u uuid.UUID) {
	m.item = &u
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *SerialMutation) ItemID() (r uuid.UUID, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the Serial entity.
// If the Serial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerialMutation) OldItemID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ResetItemID resets all changes to the "item_id" field.
func (m *SerialMutation) ResetItemID() {
	m.item = nil
}

// ClearItem clears the "item" edge to the Item entity.
func (m *SerialMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *SerialMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *SerialMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *SerialMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// ClearStorage clears the "storage" edge to the Storage entity.
func (m *SerialMutation) ClearStorage() {
	m.clearedstorage = true
}

// StorageCleared reports if the "storage" edge to the Storage entity was cleared.
func (m *SerialMutation) StorageCleared() bool {
	return m.clearedstorage
}

// StorageIDs returns the "storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageID instead. It exists only for internal usage by the builders.
func (m *SerialMutation) StorageIDs() (ids []uuid.UUID) {
	if id := m.storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorage resets all changes to the "storage" edge.
func (m *SerialMutation) ResetStorage() {
	m.storage = nil
	m.clearedstorage = false
}

// Where appends a list predicates to the SerialMutation builder.
func (m *SerialMutation) Where(ps ...predicate.Serial) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SerialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Serial).
func (m *SerialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SerialMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, serial.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serial.FieldUpdateTime)
	}
	if m.storage != nil {
		fields = append(fields, serial.FieldStorageID)
	}
	if m.item != nil {
		fields = append(fields, serial.FieldItemID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SerialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serial.FieldCreateTime:
		return m.CreateTime()
	case serial.FieldUpdateTime:
		return m.UpdateTime()
	case serial.FieldStorageID:
		return m.StorageID()
	case serial.FieldItemID:
		return m.ItemID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SerialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serial.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serial.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serial.FieldStorageID:
		return m.OldStorageID(ctx)
	case serial.FieldItemID:
		return m.OldItemID(ctx)
	}
	return nil, fmt.Errorf("unknown Serial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serial.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serial.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serial.FieldStorageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageID(v)
		return nil
	case serial.FieldItemID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	}
	return fmt.Errorf("unknown Serial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SerialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SerialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Serial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SerialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SerialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SerialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Serial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SerialMutation) ResetField(name string) error {
	switch name {
	case serial.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serial.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serial.FieldStorageID:
		m.ResetStorageID()
		return nil
	case serial.FieldItemID:
		m.ResetItemID()
		return nil
	}
	return fmt.Errorf("unknown Serial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SerialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, serial.EdgeItem)
	}
	if m.storage != nil {
		edges = append(edges, serial.EdgeStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SerialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serial.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case serial.EdgeStorage:
		if id := m.storage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SerialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SerialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SerialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, serial.EdgeItem)
	}
	if m.clearedstorage {
		edges = append(edges, serial.EdgeStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SerialMutation) EdgeCleared(name string) bool {
	switch name {
	case serial.EdgeItem:
		return m.cleareditem
	case serial.EdgeStorage:
		return m.clearedstorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SerialMutation) ClearEdge(name string) error {
	switch name {
	case serial.EdgeItem:
		m.ClearItem()
		return nil
	case serial.EdgeStorage:
		m.ClearStorage()
		return nil
	}
	return fmt.Errorf("unknown Serial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SerialMutation) ResetEdge(name string) error {
	switch name {
	case serial.EdgeItem:
		m.ResetItem()
		return nil
	case serial.EdgeStorage:
		m.ResetStorage()
		return nil
	}
	return fmt.Errorf("unknown Serial edge %s", name)
}

// StorageMutation represents an operation that mutates the Storage nodes in the graph.
type StorageMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	location              *string
	clearedFields         map[string]struct{}
	storage_serial        map[string]struct{}
	removedstorage_serial map[string]struct{}
	clearedstorage_serial bool
	done                  bool
	oldValue              func(context.Context) (*Storage, error)
	predicates            []predicate.Storage
}

var _ ent.Mutation = (*StorageMutation)(nil)

// storageOption allows management of the mutation configuration using functional options.
type storageOption func(*StorageMutation)

// newStorageMutation creates new mutation for the Storage entity.
func newStorageMutation(c config, op Op, opts ...storageOption) *StorageMutation {
	m := &StorageMutation{
		config:        c,
		op:            op,
		typ:           TypeStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageID sets the ID field of the mutation.
func withStorageID(id uuid.UUID) storageOption {
	return func(m *StorageMutation) {
		var (
			err   error
			once  sync.Once
			value *Storage
		)
		m.oldValue = func(ctx context.Context) (*Storage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Storage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorage sets the old Storage of the mutation.
func withStorage(node *Storage) storageOption {
	return func(m *StorageMutation) {
		m.oldValue = func(context.Context) (*Storage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Storage entities.
func (m *StorageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Storage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StorageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StorageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StorageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StorageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StorageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StorageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *StorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StorageMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *StorageMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *StorageMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *StorageMutation) ResetLocation() {
	m.location = nil
}

// AddStorageSerialIDs adds the "storage_serial" edge to the Serial entity by ids.
func (m *StorageMutation) AddStorageSerialIDs(ids ...string) {
	if m.storage_serial == nil {
		m.storage_serial = make(map[string]struct{})
	}
	for i := range ids {
		m.storage_serial[ids[i]] = struct{}{}
	}
}

// ClearStorageSerial clears the "storage_serial" edge to the Serial entity.
func (m *StorageMutation) ClearStorageSerial() {
	m.clearedstorage_serial = true
}

// StorageSerialCleared reports if the "storage_serial" edge to the Serial entity was cleared.
func (m *StorageMutation) StorageSerialCleared() bool {
	return m.clearedstorage_serial
}

// RemoveStorageSerialIDs removes the "storage_serial" edge to the Serial entity by IDs.
func (m *StorageMutation) RemoveStorageSerialIDs(ids ...string) {
	if m.removedstorage_serial == nil {
		m.removedstorage_serial = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.storage_serial, ids[i])
		m.removedstorage_serial[ids[i]] = struct{}{}
	}
}

// RemovedStorageSerial returns the removed IDs of the "storage_serial" edge to the Serial entity.
func (m *StorageMutation) RemovedStorageSerialIDs() (ids []string) {
	for id := range m.removedstorage_serial {
		ids = append(ids, id)
	}
	return
}

// StorageSerialIDs returns the "storage_serial" edge IDs in the mutation.
func (m *StorageMutation) StorageSerialIDs() (ids []string) {
	for id := range m.storage_serial {
		ids = append(ids, id)
	}
	return
}

// ResetStorageSerial resets all changes to the "storage_serial" edge.
func (m *StorageMutation) ResetStorageSerial() {
	m.storage_serial = nil
	m.clearedstorage_serial = false
	m.removedstorage_serial = nil
}

// Where appends a list predicates to the StorageMutation builder.
func (m *StorageMutation) Where(ps ...predicate.Storage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StorageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Storage).
func (m *StorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, storage.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, storage.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, storage.FieldName)
	}
	if m.location != nil {
		fields = append(fields, storage.FieldLocation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storage.FieldCreateTime:
		return m.CreateTime()
	case storage.FieldUpdateTime:
		return m.UpdateTime()
	case storage.FieldName:
		return m.Name()
	case storage.FieldLocation:
		return m.Location()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case storage.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case storage.FieldName:
		return m.OldName(ctx)
	case storage.FieldLocation:
		return m.OldLocation(ctx)
	}
	return nil, fmt.Errorf("unknown Storage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storage.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case storage.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case storage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storage.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Storage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Storage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageMutation) ResetField(name string) error {
	switch name {
	case storage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case storage.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case storage.FieldName:
		m.ResetName()
		return nil
	case storage.FieldLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.storage_serial != nil {
		edges = append(edges, storage.EdgeStorageSerial)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storage.EdgeStorageSerial:
		ids := make([]ent.Value, 0, len(m.storage_serial))
		for id := range m.storage_serial {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstorage_serial != nil {
		edges = append(edges, storage.EdgeStorageSerial)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storage.EdgeStorageSerial:
		ids := make([]ent.Value, 0, len(m.removedstorage_serial))
		for id := range m.removedstorage_serial {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstorage_serial {
		edges = append(edges, storage.EdgeStorageSerial)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageMutation) EdgeCleared(name string) bool {
	switch name {
	case storage.EdgeStorageSerial:
		return m.clearedstorage_serial
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Storage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageMutation) ResetEdge(name string) error {
	switch name {
	case storage.EdgeStorageSerial:
		m.ResetStorageSerial()
		return nil
	}
	return fmt.Errorf("unknown Storage edge %s", name)
}

// SupplierMutation represents an operation that mutates the Supplier nodes in the graph.
type SupplierMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	phone         *string
	email         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Supplier, error)
	predicates    []predicate.Supplier
}

var _ ent.Mutation = (*SupplierMutation)(nil)

// supplierOption allows management of the mutation configuration using functional options.
type supplierOption func(*SupplierMutation)

// newSupplierMutation creates new mutation for the Supplier entity.
func newSupplierMutation(c config, op Op, opts ...supplierOption) *SupplierMutation {
	m := &SupplierMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierID sets the ID field of the mutation.
func withSupplierID(id uuid.UUID) supplierOption {
	return func(m *SupplierMutation) {
		var (
			err   error
			once  sync.Once
			value *Supplier
		)
		m.oldValue = func(ctx context.Context) (*Supplier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Supplier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplier sets the old Supplier of the mutation.
func withSupplier(node *Supplier) supplierOption {
	return func(m *SupplierMutation) {
		m.oldValue = func(context.Context) (*Supplier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Supplier entities.
func (m *SupplierMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Supplier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SupplierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SupplierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SupplierMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMutation) ResetPhone() {
	m.phone = nil
}

// SetEmail sets the "email" field.
func (m *SupplierMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupplierMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SupplierMutation) ResetEmail() {
	m.email = nil
}

// Where appends a list predicates to the SupplierMutation builder.
func (m *SupplierMutation) Where(ps ...predicate.Supplier) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SupplierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Supplier).
func (m *SupplierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, supplier.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, supplier.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplier.FieldName:
		return m.Name()
	case supplier.FieldPhone:
		return m.Phone()
	case supplier.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplier.FieldName:
		return m.OldName(ctx)
	case supplier.FieldPhone:
		return m.OldPhone(ctx)
	case supplier.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Supplier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case supplier.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case supplier.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Supplier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Supplier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMutation) ResetField(name string) error {
	switch name {
	case supplier.FieldName:
		m.ResetName()
		return nil
	case supplier.FieldPhone:
		m.ResetPhone()
		return nil
	case supplier.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Supplier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Supplier edge %s", name)
}
